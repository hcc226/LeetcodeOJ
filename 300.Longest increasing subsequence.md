# LeetCode 300: Longest Increasing Subsequence - Solution Analysis

**Problem Link**: [LeetCode 300 - Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

## Problem Overview
Find the length of the longest strictly increasing subsequence in an array.

---

## Solution 1: Dynamic Programming (Intuitive Approach)

### Code
```typescript
function lengthOfLIS(nums: number[]): number {
    const len = nums.length;
    const dpIncreasingLen = new Array(len).fill(1); // 当前位置的最长增长长度
    let res = dpIncreasingLen[0];
    for (let i = 1; i < len; i++ ) {
        let previous = i - 1;
        while(previous > -1) {
            if (nums[i] > nums[previous]) {
                dpIncreasingLen[i] = Math.max(dpIncreasingLen[previous] + 1, dpIncreasingLen[i]);
            } 
            previous--;
        }
        res = Math.max(dpIncreasingLen[i], res);
    }
    return res;
}
```

### Approach Explanation

**Core Idea**: Use dynamic programming where `dp[i]` represents the length of the longest increasing subsequence ending at index `i`.

**Algorithm Steps**:
1. Initialize `dp` array with all values as 1 (each element forms a subsequence of length 1)
2. For each position `i`, look back at all previous positions `j` (where `j < i`)
3. If `nums[i] > nums[j]`, then `nums[i]` can extend the subsequence ending at `j`
4. Update `dp[i] = max(dp[i], dp[j] + 1)`
5. Track the maximum value in the `dp` array as the result

**Example**: For `nums = [10, 9, 2, 5, 3, 7, 101, 18]`
- `dp[0] = 1` → [10]
- `dp[3] = 2` → [2, 5]
- `dp[5] = 3` → [2, 5, 7]
- `dp[6] = 4` → [2, 5, 7, 101]

### Complexity Analysis
- **Time Complexity**: O(n²) - nested loops through all pairs of elements
- **Space Complexity**: O(n) - `dp` array storage
- **Pros**: Easy to understand and implement
- **Cons**: Inefficient for large inputs

---

## Solution 2: Greedy + Binary Search (Optimal Approach)

### Code
```typescript
function findTargetIndex(nums: number[], curr: number) {
    const len = nums.length;
    let left = 0, right = nums.length - 1;
    while(left < right) {
        let mid = Math.floor((left + right) / 2);
        if (nums[mid] === curr) {
            return mid;
        }
        if (nums[mid] < curr) {
            left = mid + 1;
        } else {
            // curr < nums[mid]
            if (mid === 0) {
                return mid;
            }
            if (mid - 1 >= 0 && curr > nums[mid - 1]) {
                return mid;
            } else {
                right = mid - 1;
            }
        }
    }
    return right;
}

function lengthOfLIS(nums: number[]): number {
    // 记录最长递增数组的最小末尾值，因为这个对于后续的计算是最优的
    let len = nums.length;
    let tails = [nums[0]]; // 长度为1的数组的最小末尾值
    for(let i = 1; i < len; i++) {
        if(nums[i] > tails[tails.length - 1]) {
            // increase
            tails.push(nums[i]);
        } else {
            // not increase
            const index = findTargetIndex(tails, nums[i]);
            tails[index] = nums[i];
        }
    }
    return tails.length;
}
```

### Approach Explanation

**Core Idea**: Maintain a `tails` array where `tails[i]` represents the **smallest ending element** of all increasing subsequences of length `i+1`. This greedy strategy is optimal because smaller ending values maximize opportunities to extend subsequences with future elements.

**Algorithm Steps**:
1. Initialize `tails` with the first element
2. For each subsequent element `nums[i]`:
   - **If `nums[i] > tails[last]`**: Current number can extend the longest subsequence → append it to `tails`
   - **Otherwise**: Use binary search to find the position where `nums[i]` should replace an existing value to maintain the smallest possible ending values

**Binary Search Helper (`findTargetIndex`)**:
- Finds the **leftmost position** where `curr` should be inserted to maintain sorted order
- This is the position of the smallest element in `tails` that is greater than or equal to `curr`
- When we replace that element with `curr`, we're keeping a smaller ending value for that subsequence length

**Example**: For `nums = [10, 9, 2, 5, 3, 7, 101, 18]`
- `i=0`: `tails = [10]`
- `i=1`: `9 < 10` → replace → `tails = [9]`
- `i=2`: `2 < 9` → replace → `tails = [2]`
- `i=3`: `5 > 2` → append → `tails = [2, 5]`
- `i=4`: `3 < 5` → replace 5 → `tails = [2, 3]`
- `i=5`: `7 > 3` → append → `tails = [2, 3, 7]`
- `i=6`: `101 > 7` → append → `tails = [2, 3, 7, 101]`
- `i=7`: `18 < 101` → replace 101 → `tails = [2, 3, 7, 18]`
- **Result**: Length = 4

**Why This Works**: By keeping the smallest possible ending values at each length, we maximize the probability that future elements can extend the subsequences. The `tails` array doesn't necessarily represent an actual subsequence, but its length equals the LIS length.

### Complexity Analysis
- **Time Complexity**: O(n log n) - n iterations × O(log n) binary search per iteration
- **Space Complexity**: O(n) - `tails` array (worst case: all elements form increasing sequence)
- **Pros**: Optimal time complexity, efficient for large inputs
- **Cons**: More complex to understand and implement

---

## Comparison

| Aspect | Dynamic Programming | Greedy + Binary Search |
|--------|-------------------|----------------------|
| Time Complexity | O(n²) | O(n log n) |
| Space Complexity | O(n) | O(n) |
| Difficulty | Easy | Medium |
| Best For | Small inputs, learning | Large inputs, interviews |

**Recommendation**: The greedy + binary search approach is the preferred solution for interviews and production code due to its superior time complexity.