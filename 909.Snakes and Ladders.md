# üêç Snakes and Ladders ‚Äî Solution Explanation (BFS Approach)
## üß© Problem Summary

We are given an n x n board representing a Snakes and Ladders game.
Each cell can either:

Be a normal square (value -1)

Contain a ladder or snake, leading to another square number.

You start at square 1 and want to reach square n¬≤.
Each move, you can roll a die (1‚Äì6) and move forward accordingly.
If you land on a square with a ladder/snake, you must immediately move to the destination square.

Goal: Find the minimum number of dice rolls to reach the last square.
If it‚Äôs impossible, return -1.

## üí° Core Idea

This is essentially a shortest path problem on an unweighted graph, where:

Each square is a node.

An edge exists between a square and the next 6 possible positions.

The best way to find the shortest path here is Breadth-First Search (BFS).

## ‚öôÔ∏è Step-by-Step Solution
### 1. Convert board coordinates to number positions

The board is labeled in a boustrophedon order (alternating left-to-right and right-to-left).
To translate a square number into its (row, col) coordinates, we use this helper function:
```
function getRowAndCol(num, size): [number, number] {
    const rowIdx = Math.floor((num - 1) / size);
    const colIdx = (num - 1) % size;

    const row = size - 1 - rowIdx;
    const col = (rowIdx % 2) ? size - 1 - colIdx : colIdx;

    return [row, col];
}
```

Explanation:

rowIdx and colIdx give the zero-based position in a top-down flattened grid.

The row index is reversed (size - 1 - rowIdx) because the board numbering starts at the bottom.

For every odd row, the direction is reversed (right-to-left), hence the column adjustment.

### 2. BFS Initialization

We create:

steps: an array to record the minimum steps to reach each square.

queue: to perform BFS level-order traversal.
```
const size = board.length;
const target = size * size;
const steps = new Array(target + 1).fill(-1);
steps[1] = 0;
const queue = [1];
```

Initially:

Start from square 1

Step count = 0

### 3. BFS Loop

For each position, simulate rolling a dice (1 to 6):
```
while (queue.length) {
    const currentNum = queue.shift();

    for (let i = currentNum + 1; i <= Math.min(currentNum + 6, target); i++) {
        const [row, col] = getRowAndCol(i, size);
        const nextNum = board[row][col];
```

If the destination (i or nextNum) is the target, return immediately.

Otherwise:

If there‚Äôs no snake or ladder (nextNum === -1), push i into queue.

If there is a snake or ladder, push the nextNum destination.

### 4. Step Updates
```
if (i === target || nextNum === target) {
    return steps[currentNum] + 1;
}

if (steps[i] === -1 && nextNum === -1) {
    steps[i] = steps[currentNum] + 1;
    queue.push(i);
}

if (steps[nextNum] === -1 && nextNum !== -1) {
    steps[nextNum] = steps[currentNum] + 1;
    queue.push(nextNum);
}
```

Only update steps for squares that haven‚Äôt been visited (steps[x] === -1).

This ensures each node is processed once ‚Üí guaranteeing shortest path property.

### 5. Return Result

If BFS finishes and we never reached the target:

return -1;

## üßÆ Time & Space Complexity
Metric	Complexity	Explanation
Time	O(n¬≤)	Each cell is visited once, exploring up to 6 moves
Space	O(n¬≤)	BFS queue + steps array
## ‚úÖ Key Takeaways

Use BFS for shortest-path problems in an unweighted game grid.

Carefully handle the boustrophedon numbering system.

Track visited squares using a steps array to avoid revisiting.

Early return when reaching target improves performance.

## üöÄ Possible Optimizations

Flatten the board at the start to avoid repeatedly calling getRowAndCol() inside BFS.

Replace queue.shift() with two-pointer indexing to achieve O(1) dequeue.

Add an early return if current + 6 >= target.

Use clearer level-based BFS loops for readability.


Most important: BFS naturally guarantees the shortest path