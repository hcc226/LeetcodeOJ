# LeetCode 208: Implement Trie (Prefix Tree)

**Problem Link**: https://leetcode.com/problems/implement-trie-prefix-tree/

## Problem Description

Implement a Trie (prefix tree) data structure with the following operations:
- `insert(word)`: Inserts a word into the trie
- `search(word)`: Returns true if the word is in the trie
- `startsWith(prefix)`: Returns true if there is any word in the trie that starts with the given prefix

## Solution Approach

### Data Structure Design

**TrieNode Structure:**
```typescript
class TrieNode {
    children: Map<string, TrieNode>;  // Maps character to child node
    isEndOfWord: boolean;              // Marks complete word ending
}
```

**Why use Map instead of Array?**
- **Array approach**: O(26) or O(k) lookup time for each character
- **Map approach**: O(1) average lookup time
- More efficient for sparse character sets

### Algorithm Breakdown

#### 1. Insert Operation
**Time Complexity**: O(m) where m = word length

**Steps:**
1. Start from the root node
2. For each character in the word:
   - If the character doesn't exist in current node's children, create a new node
   - Move to the child node
3. Mark the last node as end of word

**Visualization:**
```
Insert "app", "apple", "apply"

       root
        |
        a
        |
        p
        |
        p (isEndOfWord: true) ← "app"
       / \
      l   l
      |   |
      e   y
      ↑   ↑
   "apple" "apply"
```

#### 2. Search Operation
**Time Complexity**: O(m) where m = word length

**Steps:**
1. Use helper method `searchPrefix` to traverse the trie
2. If prefix path doesn't exist, return false
3. If path exists, check if the final node is marked as end of word

**Key Insight**: Extract common logic into `searchPrefix` to avoid code duplication between `search` and `startsWith`

#### 3. StartsWith Operation
**Time Complexity**: O(m) where m = prefix length

**Steps:**
1. Use `searchPrefix` to find if the prefix path exists
2. Return true if any path matches the prefix (no need to check `isEndOfWord`)

### Code Implementation

```typescript
class TrieNode {
    children: Map<string, TrieNode>;
    isEndOfWord: boolean;

    constructor() {
        this.children = new Map();
        this.isEndOfWord = false;
    }
}

class Trie {
    private root: TrieNode;

    constructor() {
        this.root = new TrieNode();
    }

    insert(word: string): void {
        let node = this.root;
        for (const char of word) {
            if (!node.children.has(char)) {
                node.children.set(char, new TrieNode());
            }
            node = node.children.get(char)!;
        }
        node.isEndOfWord = true;
    }

    search(word: string): boolean {
        const node = this.searchPrefix(word);
        return node !== null && node.isEndOfWord;
    }
 
    startsWith(prefix: string): boolean {
        return this.searchPrefix(prefix) !== null;
    }

    private searchPrefix(prefix: string): TrieNode | null {
        let node = this.root;
        for (const char of prefix) {
            if (!node.children.has(char)) {
                return null;
            }
            node = node.children.get(char)!;
        }
        return node;
    }
}
```

## Complexity Analysis

| Operation | Time Complexity | Space Complexity |
|-----------|----------------|------------------|
| Insert    | O(m)           | O(m)             |
| Search    | O(m)           | O(1)             |
| StartsWith| O(m)           | O(1)             |

Where:
- m = length of the word/prefix
- Overall space: O(ALPHABET_SIZE × N × M) where N = number of words, M = average word length

## Key Optimization Points

1. **Map vs Array**: Using Map provides O(1) lookup instead of O(k) iteration
2. **Code Reusability**: `searchPrefix` method eliminates duplication
3. **Memory Efficiency**: Only store characters in Map keys, no need for `val` property in nodes
4. **Clear Naming**: `isEndOfWord` is more descriptive than `hasWord`

## Alternative Approaches

### Naive Set Approach
```typescript
class Trie {
    private dict: Set<string>;
    
    insert(word: string): void {
        this.dict.add(word);
    }
    
    search(word: string): boolean {
        return this.dict.has(word);
    }
    
    startsWith(prefix: string): boolean {
        return Array.from(this.dict).some(w => w.startsWith(prefix));
    }
}
```

**Why Trie is Better:**
- `startsWith` in Set approach: O(n × m) time complexity
- `startsWith` in Trie approach: O(m) time complexity
- Trie excels at prefix-based operations

## Common Pitfalls to Avoid

1. ❌ Forgetting to mark `isEndOfWord` after insertion
2. ❌ Returning true in `search` if only prefix exists
3. ❌ Not handling null checks in `searchPrefix`
4. ❌ Using inefficient data structures (array instead of Map)

## Related Problems

- [211. Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/)
- [212. Word Search II](https://leetcode.com/problems/word-search-ii/)
- [1268. Search Suggestions System](https://leetcode.com/problems/search-suggestions-system/)
- [648. Replace Words](https://leetcode.com/problems/replace-words/)

## Practical Applications

1. **Autocomplete systems** (search engines, IDEs)
2. **Spell checkers**
3. **IP routing** (longest prefix matching)
4. **Dictionary implementations**
5. **DNA sequence analysis**