### 题目描述
```
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:

输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]

```
链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array


### 我的AC代码
```
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    for(let i = 0; i < nums.length; i++) {
        if (nums[Math.abs(nums[i]) - 1] > 0) {
            nums[Math.abs(nums[i]) - 1] *= -1;
        }
    }
    let res = [];
    for(let i = 0; i < nums.length; i++) {
        if(nums[i] > 0) {
            res.push(i+1);
        }
    }
    return res;
};
```


### 题解思路
根据题目特点，可以把数组中的元素与索引建立一一对应的关系。因为索引是确定的0到n-1,一个也不缺，而数组的元素不确定，少了哪个也不知道。
既然两者是一一对应的关系，那么我们对数组中的每个元素对应的索引做个标记；
然后再对索引进行一次遍历，那么不存的元素就不会对它对应的索引进行比较，由此可查找出这些不存在的元素。
例如对于数组nums = [4,3,2,7,8,2,3,1]
依次遍历，首先对于第一个元素4，我们将nums[4 - 1]的值置为负数，证明该值（【4】）已经出现过。
那么然后对于元素3，我们将nums[3 - 1]的值置为负数，证明该值（【3】）已经出现过，
最后得到的数组是[-4, -3, -2, -7, 8, 2, -3, 1]
最后再遍历这个数组，发现位置【4，5】上的元素【8，2】为负数，证明数字【5，6】没有出现过，那么返回的结果是【5，6】
