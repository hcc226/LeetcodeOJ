# Minimum Path Sum - Solution Explanation

**LeetCode Problem**: [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)

## Problem Description
Given an m×n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along the path. You can only move either down or right at any point.

## Solution Approach

### Dynamic Programming Method (Recommended)

**Core Idea**: Starting from the origin, progressively calculate the minimum path sum to reach each position.

**State Definition**:
- `dp[i][j]` represents the minimum path sum from the starting point `(0,0)` to position `(i,j)`

**State Transition Equation**:
```
dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
```
Since you can only reach the current position from above or from the left, choose the direction with the smaller path sum.

**Calculation Order**:
1. **Initialize first row**: Can only be reached from the left, cumulative sum
   ```
   dp[0][j] = dp[0][j-1] + grid[0][j]
   ```

2. **Initialize first column**: Can only be reached from above, cumulative sum
   ```
   dp[i][0] = dp[i-1][0] + grid[i][0]
   ```

3. **Fill remaining cells**: Fill row by row or column by column using the state transition equation

**Time Complexity**: O(m×n)  
**Space Complexity**: O(m×n), can be optimized to O(n)

### Analysis of Your Original Approach

Your approach uses **reverse dynamic programming** (calculating from end to start):
- Start from the bottom-right corner, calculate backwards along diagonals
- For each position, choose the minimum between right and bottom, then add current value

**Issues**:
- Complex calculation order requiring diagonal traversal
- Poor code readability, error-prone
- While theoretically viable, implementation is much more complex than forward DP

### Code Implementation (Forward DP)

```typescript
function minPathSum(grid: number[][]): number {
    const m = grid.length;
    const n = grid[0].length;
    
    // Create dp array
    const dp = Array.from({ length: m }, () => new Array(n).fill(0));
    
    // Initialize starting point
    dp[0][0] = grid[0][0];
    
    // Initialize first row
    for (let j = 1; j < n; j++) {
        dp[0][j] = dp[0][j-1] + grid[0][j];
    }
    
    // Initialize first column
    for (let i = 1; i < m; i++) {
        dp[i][0] = dp[i-1][0] + grid[i][0];
    }
    
    // Fill remaining positions
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
        }
    }
    
    return dp[m-1][n-1];
}
```

### Example Walkthrough

Input:
```
grid = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
```

DP array calculation process:
```
After initialization:
[1, 4, 5]
[2, 0, 0]
[6, 0, 0]

After filling:
[1, 4, 5]
[2, 7, 6]
[6, 8, 7]
```

Minimum path sum: 7 (Path: 1→3→1→1→1)

### Space-Optimized Version

Since each position only depends on the cell above and to the left, we can optimize using a 1D array:

```typescript
function minPathSum(grid: number[][]): number {
    const m = grid.length;
    const n = grid[0].length;
    const dp = new Array(n);
    
    // Initialize first row
    dp[0] = grid[0][0];
    for (let j = 1; j < n; j++) {
        dp[j] = dp[j-1] + grid[0][j];
    }
    
    // Process remaining rows
    for (let i = 1; i < m; i++) {
        dp[0] += grid[i][0];
        for (let j = 1; j < n; j++) {
            dp[j] = Math.min(dp[j], dp[j-1]) + grid[i][j];
        }
    }
    
    return dp[n-1];
}
```

Space Complexity: O(n)

### Key Takeaways

1. **Forward DP is clearer**: Computing from start to end follows natural intuition
2. **Edge cases matter**: Properly handle first row and first column
3. **Space optimization**: When each state only depends on previous row/column, consider 1D array
4. **Trade-offs**: Your reverse approach works but adds unnecessary complexity