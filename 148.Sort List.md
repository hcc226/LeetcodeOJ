# 148. Sort List - Three Solution Approaches

**LeetCode Problem:** [148. Sort List](https://leetcode.com/problems/sort-list/)

## Solution 1: Array Conversion (Easy Approach)

### Approach
Convert the linked list to an array, sort the array using built-in sort, then reconstruct a new linked list from the sorted array.

### Algorithm
1. Traverse the linked list and store all values in an array
2. Sort the array using JavaScript's built-in sort method
3. Create a new linked list from the sorted array values

### Code
```typescript
function sortList(head: ListNode | null): ListNode | null {
    if (!head) return null;
    
    const nodeValueArr: number[] = [];
    while(head){
        nodeValueArr.push(head.val);
        head = head.next;
    }
    
    nodeValueArr.sort((a, b) => a - b);
    
    const newHead = new ListNode(nodeValueArr[0]);
    let newPointer = newHead;
    for(let i = 1; i < nodeValueArr.length; i++) {
        newPointer.next = new ListNode(nodeValueArr[i]);
        newPointer = newPointer.next;
    }
    return newHead;
}
```

### Complexity
- **Time Complexity:** O(n log n) - due to sorting
- **Space Complexity:** O(n) - array storage

### Pros & Cons
✅ Simple and straightforward implementation  
✅ Easy to understand  
❌ Uses O(n) extra space  
❌ Creates new nodes instead of reusing existing ones

---

## Solution 2: Merge Sort (Top-Down / Recursive)

### Approach
Classic merge sort implementation using recursion. Find the middle of the list, recursively sort both halves, then merge them together.

### Algorithm
1. Base case: if list is empty or has one node, return it
2. Use slow/fast pointer technique to find the middle node
3. Split the list into two halves
4. Recursively sort both halves
5. Merge the two sorted halves

### Code
```typescript
function sortList(head: ListNode | null): ListNode | null {
    if (!head || !head.next) return head;
    
    // Find middle using slow/fast pointers
    let slow = head;
    let fast = head.next;
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Split the list
    const slowNext = slow.next;
    slow.next = null;
    
    // Recursively sort both halves
    const left = sortList(head);
    const right = sortList(slowNext);
    
    // Merge sorted halves
    return merge(left, right);
}

function merge(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    const mergeHead = new ListNode();
    let res = mergeHead;
    
    while(l1 && l2) {
        if (l1.val < l2.val) {
            mergeHead.next = new ListNode(l1.val);
            l1 = l1.next;
        } else {
            mergeHead.next = new ListNode(l2.val);
            l2 = l2.next;
        }
        mergeHead = mergeHead.next;
    }
    
    while(l1) {
        mergeHead.next = new ListNode(l1.val);
        l1 = l1.next;
        mergeHead = mergeHead.next;
    }
    
    while(l2) {
        mergeHead.next = new ListNode(l2.val);
        l2 = l2.next;
        mergeHead = mergeHead.next;
    }
    
    return res.next;
}
```

### Complexity
- **Time Complexity:** O(n log n) - divide and conquer
- **Space Complexity:** O(log n) - recursion call stack

### Pros & Cons
✅ Classic approach, commonly used in interviews  
✅ Intuitive divide-and-conquer logic  
❌ Uses O(log n) space for recursion stack  
❌ Doesn't meet O(1) space requirement

---

## Solution 3: Merge Sort (Bottom-Up / Iterative) ⭐

### Approach
Iterative merge sort that achieves O(1) space complexity. Sort by merging increasingly larger sublists, starting from size 1.

### Algorithm
1. Calculate the total length of the linked list
2. Start with sublist size = 1
3. For each iteration:
   - Split the list into pairs of sublists of current size
   - Merge each pair
   - Double the sublist size
4. Repeat until size >= length

### Code
```typescript
function sortList(head: ListNode | null): ListNode | null {
    if (!head) return null;
    
    // Calculate list length
    let copy = head;
    let len = 0;
    while(copy) {
        copy = copy.next;
        len++;
    }
    
    let size = 1;
    let dummy = new ListNode();
    dummy.next = head;
    
    while(size < len) {
        let curr = dummy.next;
        let tail = dummy;
        
        while(curr) {
            let left = curr;
            let right = split(left, size);
            curr = split(right, size);
            tail = merge(left, right, tail);
        }
        size = size * 2;
    }
    
    return dummy.next;
}

function split(l: ListNode | null, size: number): ListNode | null {
    if (!l) return null;
    
    let res = l;
    for(let i = 1; i < size && res.next; i++) {
        res = res.next;
    }
    
    const nextHead = res.next;
    res.next = null;
    return nextHead;
}

function merge(l1: ListNode | null, l2: ListNode | null, tail: ListNode | null): ListNode {
    while(l1 && l2) {
        if (l1.val < l2.val) {
            tail.next = l1;
            l1 = l1.next;
        } else {
            tail.next = l2;
            l2 = l2.next;
        }
        tail = tail.next;
    }
    
    tail.next = l1 || l2;
    while(tail.next) {
        tail = tail.next;
    }
    
    return tail;
}
```

### Complexity
- **Time Complexity:** O(n log n)
- **Space Complexity:** O(1) ✨

### Pros & Cons
✅ Meets the optimal O(1) space requirement  
✅ No recursion overhead  
✅ Reuses existing nodes  
❌ More complex logic  
❌ Harder to understand and implement

---

## Comparison Summary

| Solution | Time | Space | Difficulty | Follow-Up Requirement |
|----------|------|-------|------------|----------------------|
| Array Conversion | O(n log n) | O(n) | Easy | ❌ |
| Top-Down Merge Sort | O(n log n) | O(log n) | Medium | ❌ |
| Bottom-Up Merge Sort | O(n log n) | O(1) | Hard | ✅ |

**Recommendation:** 
- For interviews: Start with **Solution 2** (top-down) as it's intuitive
- If asked for O(1) space: Use **Solution 3** (bottom-up)
- For practice: **Solution 1** is good to understand the problem first

**Problem Link:** https://leetcode.com/problems/sort-list/