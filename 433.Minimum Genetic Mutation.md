# Solution Approach: Minimum Genetic Mutation: https://leetcode.com/problems/minimum-genetic-mutation/description/?envType=study-plan-v2&envId=top-interview-150
## Problem Understanding
This problem asks us to find the minimum number of mutations needed to transform a `startGene` into an `endGene`, where each mutation changes exactly one character. All intermediate genes must exist in the given `bank` array.

## Algorithm: Breadth-First Search (BFS)

### Why BFS?
BFS is ideal for finding the shortest path in an unweighted graph. Here, each gene is a node, and an edge exists between two genes if they differ by exactly one character. BFS guarantees we find the minimum number of mutations.

### Key Components

1. **Helper Function - `isChangedOne`**
   - Compares two gene strings character by character
   - Returns `true` if exactly one character differs
   - This determines if a direct mutation is possible between two genes

2. **Main Algorithm Steps**

   **Initialization:**
   - Create a queue and initialize it with `startGene`
   - Use a Map (`muationsMap`) to track visited genes and their mutation counts
   - Early exit: return -1 if the bank is empty

   **BFS Process:**
   - Dequeue the current gene
   - Iterate through all genes in the bank
   - For each unvisited gene that differs by exactly one character:
     - If it's the `endGene`, return the current mutation count + 1
     - Otherwise, mark it as visited, record its mutation count, and enqueue it
   
   **Termination:**
   - If the queue is exhausted without finding `endGene`, return -1

### Time Complexity
- O(N × M × L) where:
  - N = number of genes in the bank
  - M = maximum queue size (worst case: all genes)
  - L = length of each gene string

### Space Complexity
- O(N) for the queue and mutation map

This approach efficiently explores all possible mutation paths level by level, ensuring we find the shortest transformation sequence.